## 并查集

​		并查集是一种非常精巧而实用的**树形数据结构**，它主要是处理一些**不相交集合**的**合并和查询**问题。

​		每个集合可能包含**一个或多个**元素，并选出集合中的某个元素作为**代表**。每个集合中具体包含了哪些元素是不关心的，具体选择哪个元素作为代表一般也是不关心的。我们关心的是，对于给定的元素，可以很快的找到这个元素所在的集合[的代表]，以及合并两个元素所在的集合，而且这些操作的时间复杂度都是常数级的。

## 基本操作

1. 建立一个新的并查集，其中包含s个**单元素集合**。
2. 合并集合，把元素x和元素y所在的集合**合并**，要求x和y所在的集合不相交，如果相交就不合并。
3. 找到**元素x所在的集合的代表**，这个操作也可以是用于判断两个元素是否位于同一集合，只要将他们**各自的代表比较一下**就可以了。

## 树的表现形式

​		并查集的实现原理比较简单，就是用**树**来表示一个集合，树的每个节点都是集合的一个元素，树根节点对应的就是该集合的代表。

<img src="F:\study_notes\数据结构笔记\Untitled.assets\image-20220408214542371.png" alt="image-20220408214542371" style="zoom: 67%;" />

​		比如上图中的两棵树，就跟别对应两个集合，其中第一个集合为[a, b, c, d]，代表元素是a，第二个集合为[e, f, g]，代表元素是e。

​		树的节点表示集合中的元素，指针表示指向父节点的指针，根节点的指针指向自己，表示其没有父节点。沿着每个节点的指针（父节点）不断向上查找，最终就可以找到该树的根节点，即该集合的代表元素。

#### 创建新的并查集

​		现在，假设使用一个足够长的**数组来存储树节点**，那么 makeSet 要做的就是构造出如下图的**森林**，其中每个元素都是一个单元素集合，即父节点是其自身：

![image-20220408215236108](F:\study_notes\数据结构笔记\Untitled.assets\image-20220408215236108.png)

​		接下来就是find操作了。

#### 查找

​		查找操作就是找到某个元素的**祖先**，然后直接返回。

#### 合并

​		比如我们合并 (4, 3), (3, 2), (2, 1)。

<img src="F:\study_notes\数据结构笔记\Untitled.assets\image-20220408215458272.png" alt="image-20220408215458272" style="zoom: 50%;" />

​		如果此时我们合并了一万个节点，这个时候，从时间复杂度来看，查找的次数是非常非常的多的，因此我们产生了一个策略：**路径压缩**。

## 路径压缩

​		路径压缩，就是在每次查找的时候，令查找路径上的每个节点都直接指向根节点。

<img src="F:\study_notes\数据结构笔记\Untitled.assets\image-20220408215806512.png" alt="image-20220408215806512" style="zoom: 67%;" />



## 具体实现

> 简单并查集的实现

```c
#include <stdio.h>
#include <stdlib.h>

int uset[100]; // 并查集数组
/*
	purpose: 构建并查集
	params: 
		size 总共有多少个元素
*/
void makeSet(int size) {
	for (int i = 0; i < size; i++) {
		// 下标代表真实数据元素，初始化的时候，全指向自己
		uset[i] = i;
	}
}

/*
	purpose: 查找元素的代表
	params:
		i 要查找元素的下标
*/
int find(int i) {
	// 找到代表--递归出口
	if (uset[i] == i) {
		return i;
	}

	return find(uset[i]);
}

/*
	purpose: 合并两个元素所在的集合
	params:
		x, y 两个元素
*/

void unite(int x, int y) {
	// 找到两个元素所在集合的代表
	int x = find(x);
	int y = find(y);

	// 这个两个元素已经在一个集合里面
	if (x == y) {
		return;
	}

	// 合并两个集合，让代表统一即可
	uset[x] = y;
}
```



> 采用路径压缩后的并查集的实现

```c
#include <stdio.h>
#include <stdlib.h>

/*
	路径压缩：
		在特殊情况下，这棵树会变成一个长长的链表、
		改进方法：把遍历过的节点都改成根的子节点。
*/

int node[100]; // 每个节点
int rank[100]; // 树的高度，记录树的高度

/*
	purpose: 创建并查集
	params:
		size 并查集元素的个数
*/

void makeSet(int size) {
	for (int i = 0; i < size; i++) {
		node[i] = i; // 初始化，让每个节点指向自己
		rank[i] = 0; // 高度初始化为0
	}
}

/*
	purpose: 查找某个元素所在的集合
	params:
		x 要查找的元素
*/
int find(int x) {
	if (node[x] == x) {
		return x;
	}

	// return find(node[x]); // 常规的查找元素所在集合的实现
	// 仔细考虑递归的 递过程 和 归过程
	return node[x] = find(node[x]); // 在第一次查找时，将节点直接连接到根节点
}

/*
	purpose: 合并两个元素所在的集合
	params:
		x, y 两个元素
*/
void unite(int x, int y) {
	int x = find(x);
	int y = find(y);

	// 这两个元素本身就在同一个集合中
	if (x == y) {
		return;
	}

	// 判断两棵树的高度，决定谁是谁的子树（针对集合与集合之间的合并），从而减少查找的次数
	if (rank[x] < rank[y]) {
		node[x] = y; // x 成为 y 的子树
	}
	else { // rank[x] >= rank[y]
		node[y] = x; // y 成为 x 的子树
		if (rank[x] == rank[y]) { // g
			rank[x]++;
		}
	}
}
```

