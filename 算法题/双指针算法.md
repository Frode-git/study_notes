## 一、题目描述：有序数组的平方

> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序
>
> 原题链接：https://leetcode-cn.com/problems/squares-of-a-sorted-array/

#### 题目分析：可以先将数组中的数进行平方处理，然后进行排序，或者进行排序的时候以该数的平方为比较对象

> 具体代码：

```c
vector<int> sortedSquares(vector<int>& nums) {
        vector<int> temp(nums.size()); // 一个容器，记录排序后的结果
        int i = 0, j = nums.size() - 1; // 双指针
        int k = nums.size() - 1; // 因为数组中的最大数要么在最左边，要么在最右边，因此每次记录的都是“最大数”
        while (i <= j) {
            if (nums[i] * nums[i] < nums[j] * nums[j]) {
                temp[k--] = nums[j] * nums[j];
                j--;
            }
            else {
                temp[k--] = nums[i] * nums[i];
                i++;
            }
        }
        return temp;
    }
```



## 二、轮转数组

> 将一个数组向由轮转 k 个位置。
>
> 原题链接：https://leetcode-cn.com/problems/rotate-array/

#### 题目分析：将数组轮转，就是将每个数字往后移动k位，下标溢出就回到最前面，取模就行

> 具体代码：
>
> 该方法是通过额外开辟数组实现。
>
> 时间复杂度：O(n)
>
> 空间复杂度：O(n)

```c++
void rotate(vector<int>& nums, int k) {
	int n = nums.size(); // 数组的长度
  vector<int> temp(n); // 新开辟一个同长度的数组
  
  for (int i = 0; i < n; i ++) {
     temp[(i + k) % n] = nums[i]; // 转存
  }
  
  nums = temp; // 数据更新
}
```

> 优化：
>
> ​	通过环装交替实现。
>
> ​	环装交替的原理：实现数组的轮转，就是一个数往后移动 k 位，但是这样可能会导致处在后面 k 位的数丢失，我们可以用一个变量 temp 进行存储，temp 初始化的时候存储 nums[0]，即第一个元素，然后找到后面 k 位，即 x = (0 + k) % n，然后交换 temp 和 x 位的数，再交换 temp 和 (x + k) % n 位的数，依次循环，但是我们发现，可能存在一种情况，会重新回到 0 号位，陷入死循环，对此情况，我们可以这样分析：
>
> ​	每次“死循环”的长度都是固定，比如长度为 6 的数组，k 为 2，死循环的长度就为 3，即每次只能访问到 3 个元素，如果我们能知道“死循环”的次数 count，这样只用执行 count 次即可遍历到素有的元素。
>
> ​	我们假设经过 a 圈，回到了起点，访问了 b 个元素，那么有 an = bk（总长度一致），即 an 是 k 和 n 的公倍数，又因为我们在第一次回到起点的时候就结束，因此 a 要尽可能的小，所以，an 是 k 和 n 的最小公倍数 lcm(n, k)，所以 b = lcm(n, k) / k，由此得知每次“死循环”能访问到的元素个数，进而得知执行次数为 n / b = nk / lcm(n, k) = gcd(n, k) ，即 n 和 k 的最大公约数（两数相乘 = 两数的最小公倍数 × 两数的最大公约数）

![image-20220313000215979](C:\Users\烧鸡公\AppData\Roaming\Typora\typora-user-images\image-20220313000215979.png)

```c++
void rotate(vector<int>& nums, int k) {
  int n = nums.size(); // 长度
  int count = gcd(n, k); // 求执行次数
  
  for (int start = 0; start < count; start++) {
  	int current = start; // 记录当前轮转数的下标
    int prev = nums[start]; // 记录要轮转的数
    do {
      int next = (current + k) % n; // 寻找下一个存放即将轮转数的位置
      swap(nums[next], prev); // 交换
      current = next; // 当前轮转数的下标更新
    } while(start != current); // 回到起点
  }
}
```

